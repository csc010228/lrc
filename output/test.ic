const int space = 32
const int LF = 10
const int maxNode = 10000
int value[maxNode]
int left_child[maxNode]
int right_child[maxNode]
int now
int search ( int search::root , int search::x )  : 
	EQ		search::root , -1 --> (int)@0
	IF_JMP		@0 --> .0
	MUL		search::root , 1 --> (int)@1
	ADD		@1 , 0 --> (int)@2
	EQ		value[@2] , search::x --> (int)@3
	IF_JMP		@3 --> .0
	JMP		.1
.0 : 
	RET		search::root
	JMP		.4
.1 : 
	MUL		search::root , 1 --> (int)@4
	ADD		@4 , 0 --> (int)@5
	GT		search::x , value[@5] --> (int)@6
	IF_NOT_JMP		@6 --> .2
	MUL		search::root , 1 --> (int)@7
	ADD		@7 , 0 --> (int)@8
	CALL		search ( right_child[@8] , search::x )  --> (int)@9
	RET		@9
	JMP		.3
.2 : 
	MUL		search::root , 1 --> (int)@10
	ADD		@10 , 0 --> (int)@11
	CALL		search ( left_child[@11] , search::x )  --> (int)@12
	RET		@12
.3 : 
.4 : 

int find_minimum ( int find_minimum::root )  : 
	EQ		find_minimum::root , -1 --> (int)@13
	IF_NOT_JMP		@13 --> .5
	RET		-1
	JMP		.7
.5 : 
	MUL		find_minimum::root , 1 --> (int)@14
	ADD		@14 , 0 --> (int)@15
	UEQ		left_child[@15] , -1 --> (int)@16
	IF_NOT_JMP		@16 --> .6
	MUL		find_minimum::root , 1 --> (int)@17
	ADD		@17 , 0 --> (int)@18
	CALL		find_minimum ( left_child[@18] )  --> (int)@19
	RET		@19
.6 : 
.7 : 
	RET		find_minimum::root

int new_node ( int new_node::x )  : 
	MUL		now , 1 --> (int)@20
	ADD		@20 , 0 --> (int)@21
	ASSIGN		new_node::x --> value[@21]
	MUL		now , 1 --> (int)@22
	ADD		@22 , 0 --> (int)@23
	ASSIGN		-1 --> left_child[@23]
	MUL		now , 1 --> (int)@24
	ADD		@24 , 0 --> (int)@25
	ASSIGN		-1 --> right_child[@25]
	ADD		now , 1 --> (int)@26
	ASSIGN		@26 --> now
	SUB		now , 1 --> (int)@27
	RET		@27

int insert ( int insert::root , int insert::x )  : 
	EQ		insert::root , -1 --> (int)@28
	IF_NOT_JMP		@28 --> .8
	CALL		new_node ( insert::x )  --> (int)@29
	RET		@29
	JMP		.11
.8 : 
	MUL		insert::root , 1 --> (int)@30
	ADD		@30 , 0 --> (int)@31
	GT		insert::x , value[@31] --> (int)@32
	IF_NOT_JMP		@32 --> .9
	MUL		insert::root , 1 --> (int)@33
	ADD		@33 , 0 --> (int)@34
	MUL		insert::root , 1 --> (int)@35
	ADD		@35 , 0 --> (int)@36
	CALL		insert ( right_child[@36] , insert::x )  --> (int)@37
	ASSIGN		@37 --> right_child[@34]
	JMP		.10
.9 : 
	MUL		insert::root , 1 --> (int)@38
	ADD		@38 , 0 --> (int)@39
	MUL		insert::root , 1 --> (int)@40
	ADD		@40 , 0 --> (int)@41
	CALL		insert ( left_child[@41] , insert::x )  --> (int)@42
	ASSIGN		@42 --> left_child[@39]
.10 : 
.11 : 
	RET		insert::root

int delete ( int delete::root , int delete::x )  : 
	EQ		delete::root , -1 --> (int)@43
	IF_NOT_JMP		@43 --> .12
	RET		-1
.12 : 
	MUL		delete::root , 1 --> (int)@44
	ADD		@44 , 0 --> (int)@45
	GT		delete::x , value[@45] --> (int)@46
	IF_NOT_JMP		@46 --> .13
	MUL		delete::root , 1 --> (int)@47
	ADD		@47 , 0 --> (int)@48
	MUL		delete::root , 1 --> (int)@49
	ADD		@49 , 0 --> (int)@50
	CALL		delete ( right_child[@50] , delete::x )  --> (int)@51
	ASSIGN		@51 --> right_child[@48]
	JMP		.23
.13 : 
	MUL		delete::root , 1 --> (int)@52
	ADD		@52 , 0 --> (int)@53
	LT		delete::x , value[@53] --> (int)@54
	IF_NOT_JMP		@54 --> .14
	MUL		delete::root , 1 --> (int)@55
	ADD		@55 , 0 --> (int)@56
	MUL		delete::root , 1 --> (int)@57
	ADD		@57 , 0 --> (int)@58
	CALL		delete ( left_child[@58] , delete::x )  --> (int)@59
	ASSIGN		@59 --> left_child[@56]
	JMP		.22
.14 : 
	MUL		delete::root , 1 --> (int)@60
	ADD		@60 , 0 --> (int)@61
	EQ		left_child[@61] , -1 --> (int)@62
	IF_NOT_JMP		@62 --> .15
	MUL		delete::root , 1 --> (int)@63
	ADD		@63 , 0 --> (int)@64
	EQ		right_child[@64] , -1 --> (int)@65
	IF_NOT_JMP		@65 --> .15
	RET		-1
	JMP		.21
.15 : 
	MUL		delete::root , 1 --> (int)@66
	ADD		@66 , 0 --> (int)@67
	EQ		left_child[@67] , -1 --> (int)@68
	IF_JMP		@68 --> .16
	MUL		delete::root , 1 --> (int)@69
	ADD		@69 , 0 --> (int)@70
	EQ		right_child[@70] , -1 --> (int)@71
	IF_JMP		@71 --> .16
	JMP		.19
.16 : 
	MUL		delete::root , 1 --> (int)@72
	ADD		@72 , 0 --> (int)@73
	EQ		left_child[@73] , -1 --> (int)@74
	IF_NOT_JMP		@74 --> .17
	MUL		delete::root , 1 --> (int)@75
	ADD		@75 , 0 --> (int)@76
	RET		right_child[@76]
	JMP		.18
.17 : 
	MUL		delete::root , 1 --> (int)@77
	ADD		@77 , 0 --> (int)@78
	RET		left_child[@78]
.18 : 
	JMP		.20
.19 : 
	MUL		delete::root , 1 --> (int)@79
	ADD		@79 , 0 --> (int)@80
	CALL		find_minimum ( right_child[@80] )  --> (int)@81
	int delete::else_0::tmp
	ASSIGN		@81 --> delete::else_0::tmp
	MUL		delete::root , 1 --> (int)@82
	ADD		@82 , 0 --> (int)@83
	MUL		delete::else_0::tmp , 1 --> (int)@84
	ADD		@84 , 0 --> (int)@85
	ASSIGN		value[@85] --> value[@83]
	MUL		delete::root , 1 --> (int)@86
	ADD		@86 , 0 --> (int)@87
	MUL		delete::root , 1 --> (int)@88
	ADD		@88 , 0 --> (int)@89
	MUL		delete::else_0::tmp , 1 --> (int)@90
	ADD		@90 , 0 --> (int)@91
	CALL		delete ( right_child[@89] , value[@91] )  --> (int)@92
	ASSIGN		@92 --> right_child[@87]
.20 : 
.21 : 
.22 : 
.23 : 
	RET		delete::root

void inorder ( int inorder::root )  : 
	UEQ		inorder::root , -1 --> (int)@93
	IF_NOT_JMP		@93 --> .24
	MUL		inorder::root , 1 --> (int)@94
	ADD		@94 , 0 --> (int)@95
	CALL		inorder ( left_child[@95] ) 
	MUL		inorder::root , 1 --> (int)@96
	ADD		@96 , 0 --> (int)@97
	CALL		putint ( value[@97] ) 
	CALL		putch ( space ) 
	MUL		inorder::root , 1 --> (int)@98
	ADD		@98 , 0 --> (int)@99
	CALL		inorder ( right_child[@99] ) 
.24 : 
	RET

int main (  )  : 
	ASSIGN		0 --> now
	CALL		getint (  )  --> (int)@100
	int main::n
	ASSIGN		@100 --> main::n
	NOT		main::n --> (int)@101
	IF_NOT_JMP		@101 --> .25
	RET		0
.25 : 
	CALL		getint (  )  --> (int)@102
	CALL		new_node ( @102 )  --> (int)@103
	int main::root
	ASSIGN		@103 --> main::root
	int main::i
	ASSIGN		1 --> main::i
.26 : 
	LT		main::i , main::n --> (int)@104
	IF_NOT_JMP		@104 --> .27
	CALL		getint (  )  --> (int)@105
	CALL		insert ( main::root , @105 )  --> (int)@106
	ADD		main::i , 1 --> (int)@107
	ASSIGN		@107 --> main::i
	JMP		.26
.27 : 
	CALL		inorder ( main::root ) 
	CALL		putch ( LF ) 
	CALL		getint (  )  --> (int)@108
	ASSIGN		@108 --> main::n
	ASSIGN		0 --> main::i
.28 : 
	LT		main::i , main::n --> (int)@109
	IF_NOT_JMP		@109 --> .29
	CALL		getint (  )  --> (int)@110
	CALL		delete ( main::root , @110 )  --> (int)@111
	ASSIGN		@111 --> main::root
	ADD		main::i , 1 --> (int)@112
	ASSIGN		@112 --> main::i
	JMP		.28
.29 : 
	CALL		inorder ( main::root ) 
	CALL		putch ( LF ) 
	RET		0

